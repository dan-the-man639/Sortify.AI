{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as tf from '@tensorflow/tfjs';\nimport '@tensorflow/tfjs-react-native';\nimport { bundleResourceIO, decodeJpeg } from '@tensorflow/tfjs-react-native';\nimport { Base64Binary } from \"../utils/utils\";\nvar BITMAP_DIMENSION = 224;\nvar modelJson = require(\"../model/model.json\");\nvar modelWeights = require(\"../model/weights.bin\");\nvar TENSORFLOW_CHANNEL = 3;\nexport var getModel = function getModel() {\n  return _regeneratorRuntime.async(function getModel$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(tf.ready());\n        case 3:\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(tf.loadLayersModel(bundleResourceIO(modelJson, modelWeights)));\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](0);\n          console.log('Could not load model', _context.t0);\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[0, 8]], Promise);\n};\nexport var convertBase64ToTensor = function convertBase64ToTensor(base64) {\n  var uIntArray, decodedImage;\n  return _regeneratorRuntime.async(function convertBase64ToTensor$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          uIntArray = Base64Binary.decode(base64);\n          decodedImage = decodeJpeg(uIntArray, 3);\n          return _context2.abrupt(\"return\", decodedImage.reshape([1, BITMAP_DIMENSION, BITMAP_DIMENSION, TENSORFLOW_CHANNEL]));\n        case 6:\n          _context2.prev = 6;\n          _context2.t0 = _context2[\"catch\"](0);\n          console.log('Could not convert base64 string to tesor', _context2.t0);\n        case 9:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[0, 6]], Promise);\n};\nexport var startPrediction = function startPrediction(model, tensor) {\n  var output;\n  return _regeneratorRuntime.async(function startPrediction$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(model.predict(tensor));\n        case 3:\n          output = _context3.sent;\n          return _context3.abrupt(\"return\", output.dataSync());\n        case 7:\n          _context3.prev = 7;\n          _context3.t0 = _context3[\"catch\"](0);\n          console.log('Error predicting from tesor image', _context3.t0);\n        case 10:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[0, 7]], Promise);\n};","map":{"version":3,"names":["tf","bundleResourceIO","decodeJpeg","Base64Binary","BITMAP_DIMENSION","modelJson","require","modelWeights","TENSORFLOW_CHANNEL","getModel","_regeneratorRuntime","async","getModel$","_context","prev","next","awrap","ready","loadLayersModel","abrupt","sent","t0","console","log","stop","Promise","convertBase64ToTensor","base64","uIntArray","decodedImage","convertBase64ToTensor$","_context2","decode","reshape","startPrediction","model","tensor","output","startPrediction$","_context3","predict","dataSync"],"sources":["/Users/rihong/Documents/Github/SortifyAI/helpers/tensor-helper.js"],"sourcesContent":["import * as tf from '@tensorflow/tfjs';\r\nimport '@tensorflow/tfjs-react-native';\r\nimport {bundleResourceIO, decodeJpeg} from '@tensorflow/tfjs-react-native';\r\n\r\nimport {Base64Binary} from '../utils/utils';\r\nconst BITMAP_DIMENSION = 224;\r\n\r\nconst modelJson = require('../model/model.json');\r\nconst modelWeights = require('../model/weights.bin');\r\n\r\n// 0: channel from JPEG-encoded image\r\n// 1: gray scale\r\n// 3: RGB image\r\nconst TENSORFLOW_CHANNEL = 3;\r\n\r\nexport const getModel = async () => {\r\n  try {\r\n    // wait until tensorflow is ready\r\n    await tf.ready();\r\n    // load the trained model\r\n    return await tf.loadLayersModel(bundleResourceIO(modelJson, modelWeights));\r\n  } catch (error) {\r\n    console.log('Could not load model', error);\r\n  }\r\n};\r\n\r\nexport const convertBase64ToTensor = async (base64) => {\r\n  try {\r\n    const uIntArray = Base64Binary.decode(base64);\r\n    // decode a JPEG-encoded image to a 3D Tensor of dtype\r\n    const decodedImage = decodeJpeg(uIntArray, 3);\r\n    // reshape Tensor into a 4D array\r\n    return decodedImage.reshape([\r\n      1,\r\n      BITMAP_DIMENSION,\r\n      BITMAP_DIMENSION,\r\n      TENSORFLOW_CHANNEL,\r\n    ]);\r\n  } catch (error) {\r\n    console.log('Could not convert base64 string to tesor', error);\r\n  }\r\n};\r\n\r\nexport const startPrediction = async (model, tensor) => {\r\n  try {\r\n    // predict against the model\r\n    const output = await model.predict(tensor);\r\n    // return typed array\r\n    return output.dataSync();\r\n  } catch (error) {\r\n    console.log('Error predicting from tesor image', error);\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}